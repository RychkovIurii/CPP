# `PmergeMe::sortVector` — Подробное объяснение

Ниже — **пошаговое описание работы функции** с конкретными примерами.  


---

## Общая идея

`sortVector` реализует **двухэтапный** процесс внутри саморекурсивного лямбда-движка:

1. **Фаза 1 — попарная перестановка блоков (итеративно, с удвоением `pairsize`)**  
   Массив проходит блоками размера `pairsize`.  
   Сравниваются **хвостовые** элементы соседних блоков.  
   Если хвост правого блока меньше хвоста левого — **меняются местами целые блоки**.  
   Затем рекурсия вызывается с `pairsize *= 2`, пока `pairsize` не превысит `vec.size()/2`.  
   Это формирует крупные «разумно упорядоченные» блоки при малом числе сравнений.

2. **Фаза 2 — разбиение на 2D‑чанки + пакетные вставки по Якобшталю с ограничением (якорь `a_j`)**  
   Вектор режется на равные **чанки** длиной `pairsize`, каждый получает стабильный **`id`**.  
   Чанки делятся на **основную последовательность** (`main`) и **буфер ожидания** (`pend`).  
   Элементы `pend` вставляются в `main` **пакетами Якобшталя**; диапазон бинарного поиска ограничивается **якорным чанком** `a_j`.  
   Позиция вставки определяется `std::lower_bound` по **последним элементам** чанков.  
   Когда `pend` пуст, `main` **сплющивается** обратно в `vec`.

Все сравнения проходят через ваш компаратор `CountingLess`, который увеличивает глобальный счётчик — удобно для экспериментов и профилирования количества сравнений.

---

## Каркас логики (кратко)

- **Рекурсивный драйвер** `mergeSortVec(self, pairsize, insert)`  
  - Фаза 1 выполняется, если `insert == false`:
    - Цикл по `i += pairsize * 2`
    - `mid = i + pairsize`, `end = min(i + 2*pairsize, vec.size())`
    - База: если `vec.size()/2 < pairsize` → `insert = true; return;`
    - При наличии двух полных блоков сравниваются хвосты `vec[end-1]` и `vec[mid-1]` через `CountingLess`
      - Если правый хвост `<` левого — **поменять блоки целиком**
    - Рекурсивный вызов: `self(self, pairsize*2, insert)`
  - **Фаза 2** (выполняется при раскрутке рекурсии):
    - Построение `temp` — список `VChunk{ data, id }` длиной `pairsize` (**только полные** чанки)
    - Разделение:
      - `main`: `temp[0]` (обозначается `b1`) + все **нечётные** индексы (`a1, a2, ...`)
      - `pend`: все **чётные** индексы `>= 2` (`b2, b3, ...`)
    - Инициализация: `jacob = 3`, `jacob_prev = 1`
    - Пока `pend` не пуст:
      - `batch = jacob - jacob_prev`
      - Для `i` от `0` до `batch-1` выбрать чанк из текущего окна (по индексу или последний в `pend`)
      - Найти его **исходную позицию** `j` в `temp` **по `id`**
      - Найти **якорь** `a_j = temp[j+1]` (если существует); определить его позицию в `main` по `id` → `boundElement`
      - Вычислить **границу поиска**: если `boundElement == 0`, то не ограничиваем (`bound = main.size()`), иначе `bound = boundElement`
      - `lower_bound` на `main[0..bound)` с компаратором по **последним элементам** чанков (`A.data[pairsize-1]` и `B.data[pairsize-1]`)
      - Вставить выбранный чанк в `main` на найденную позицию; удалить его из `pend` **по `id`**
      - Если `pend` опустел — **сплющить** `main` в `vec` и `return`
      - Обновить Якобшталя: `jacob, jacob_prev = jacob + 2*jacob_prev, jacob`

---

## Фаза 1 на примере — перестановка блоков

### Крошечный пример: `vec = [4, 1, 5, 2, 6, 3, 7, 0]`, `N = 8`, `N/2 = 4`

**Раунд `pairsize = 1`** (единичные блоки):
- `[4] | [1]` → `1 < 4` → свап блоков → `vec = [1, 4, 5, 2, 6, 3, 7, 0]`
- `[5] | [2]` → свап → `vec = [1, 4, 2, 5, 6, 3, 7, 0]`
- `[6] | [3]` → свап → `vec = [1, 4, 2, 5, 3, 6, 7, 0]`
- `[7] | [0]` → свап → `vec = [1, 4, 2, 5, 3, 6, 0, 7]`

**Раунд `pairsize = 2`**:
- `[1,4] | [2,5]` → хвосты `4` и `5` → `5 < 4`? нет → без действий
- `[3,6] | [0,7]` → `7 < 6`? нет → без действий

**Раунд `pairsize = 4`**:
- `[1,4,2,5] | [3,6,0,7]` → хвосты `5` и `7` → `7 < 5`? нет
- Далее пары нет → конец раунда

**Раунд `pairsize = 8`** превышает `N/2` → срабатывает база → возврат в предыдущий кадр.  
Теперь Фаза 2 пойдёт с `pairsize = 4`.

> Интуиция: Фаза 1 раскладывает данные по **крупным упорядоченным блокам**; окончательная упорядоченность достигается на Фазе 2.

---

## Фаза 2 — построение чанков, `main` и `pend`

Возьмём пример, где `pend` не пуст.

### Настройка
- Длина `N = 12`
- Фаза 1 завершилась на `pairsize = 4`
- Формируются **полные** чанки по 4 элемента (хвостовой «обрывок» короче 4 — **пропускается**)

Пусть после Фазы 1 имеем:
```
vec = [  7,  9, 12, 14,   2,  5, 11, 13,   3,  4,  6, 10 ]
          ^chunk0^        ^chunk1^          ^chunk2^
```
- `temp[0] = { [7,9,12,14], id:0 }`
- `temp[1] = { [2,5,11,13], id:1 }`
- `temp[2] = { [3,4,6,10],  id:2 }`

**Разделение (ровно как в коде):**
- `main` получает `temp[0]` (**b1**) и все **нечётные** → `temp[1]` (**a1**)  
  → `main = [ id:0 (b1), id:1 (a1) ]`
- `pend` получает **чётные индексы ≥ 2** → `temp[2]` (**b2**)  
  → `pend = [ id:2 (b2) ]`

---

## Фаза 3 — пакетные вставки по Якобшталю с ограничением якорем

Старт: `jacob = 3`, `jacob_prev = 1` → первый **пакет** `batch = 2`.

### Выбор элемента для вставки
В каждом пакете чанк выбирается из `pend` по «окну» Якобшталя; если не хватает элементов — берётся **последний**.
В примере один элемент: всегда `id:2`.

### Граница через якорь `a_j`
- Находим `jIndex` чанка в `temp` **по `id`** → `id:2` → `jIndex = 2`
- `a_j = temp[jIndex + 1]` (если существует) → здесь `jIndex+1=3` вне диапазона, якоря нет
- Код ставит `boundElement = 0` и затем:
  - `bound = (boundElement == 0) ? main.size() : boundElement` → поиск **без ограничения**

### Ключ сравнения
`lower_bound` по **хвостам** чанков:
- Для `pairsize = 4` берутся `data[3]` у `A` и `B`
- Все сравнения проходят через `CountingLess`

### Вставка и удаление
- Вставляем выбранный чанк в `main` на найденную позицию внутри `[0..bound)`
- Удаляем его из `pend` **по `id`** через `find_if`

### Сплющивание
- Как только `pend` опустеет внутри цикла — конкатенируем все чанки `main` по порядку обратно в `vec` и выходим.

---

## Мини‑трассировка Фазы 3 (для примера)

- `main = [ id:0 ({...14}), id:1 ({...13}) ]` (хвосты `14`, `13`)
- `pend = [ id:2 ({...10}) ]` (хвост `10`)

**Пакет 1** (`jacob=3`, `jacob_prev=1`, `batch=2`):
- Берём `id:2`
- Якоря нет → `bound = 2` (весь `main`)
- `lower_bound` по хвостам на `main[0..2)`:
  - `10` против `14` → позиция перед `id:0`
  - Вставляем в начало
- Удаляем `id:2` из `pend` → `pend` пуст
- **Сплющиваем**: `vec = chunk(id:2) + chunk(id:0) + chunk(id:1)`

---

## Замечания по управлению потоком

- **Почему Фаза 2 запускается после остановки рекурсии:**  
  Глубокий кадр при `vec.size()/2 < pairsize` делает `return`, **не** выполняя Фазу 2.  
  Управление возвращается в предыдущий кадр (последний с `pairsize <= vec.size()/2`), и **там** продолжается Фаза 2 с текущим `pairsize`.

- **Полнота чанков:**  
  Внутренний цикл построения чанка требует `i + pairsize <= vec.size()`.  
  То есть формируются лишь **полные чанки**; хвост короче `pairsize` сознательно **пропускается** при построении `temp`.

---

## Микро‑пример `CountingLess` на Фазе 1

`vec = [3, 1]`, `pairsize = 1`:
- `mid = 1`, `end = 2`
- Сравнение `vec[end-1]=1` и `vec[mid-1]=3` → `CountingLess(1, 3)` даёт `true` и увеличивает `g_comparisonCount`
- Свап блоков → `vec = [1, 3]`

На Фазе 3 каждое действие `lower_bound` аналогично увеличивает счётчик через `CountingLess`.